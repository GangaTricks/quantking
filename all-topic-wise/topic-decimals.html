<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>GangaTricks</title>
		<link rel="shortcut icon" href="../../icon2.png">


	
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
	<link rel="stylesheet" href="../../stylequiz.css" />
	
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- my style file gangatricks -->
 
<!-- Initialize Firebase -->
<script type="module" src="../../app.js"></script>


</head>
<body> 


<div class="container">
	<div class="navbar">
   
				<header class="headerbar">
						<div><img src="../../back-page.svg" alt="Back" width="50" height="50" onclick="goBack()" class="back-page" style="'filter: invert(38%) sepia(95%) saturate(4242%) hue-rotate(202deg) brightness(95%) contrast(80%);" /></div>
						<div><img src="../../icon1.png" width="50px" height="51px"><b style="cursor: pointer; color:  #2E58ED; padding-right: 15px; font-size: 30px;">GangaTricks</b></div>
				</header>


		<div id="sidebar" class="sidebar">
			
				<h3 onclick="toggleSidebar()" style="text-align: right; margin-right: 15px;">‚õå</h3>
				
		<div style="font-size: 10px; display: flex; justify-content: space-around;">
				
				<h6 id="userFullName"></h6>
				<img id="userPhoto" src="../../default-profile.png" width="50" height="50" alt="User Photo" />

		</div>
				<h6 id="userEmail"></h6>
				<button id="googleSignOutBtn" style="padding-left: 79%; display: none;">Sign Out</button>
				
				
				
				
				
				<a onclick="goToWebsite()" style="text-align: left; background: white; border: 2px solid lightblue;">Dashboard</a>
				<a onclick="goToHub()"  style="text-align: left; background: white; border: 2px solid lightblue;">Courses</a>
				<a onclick="goToEnglish()" style="text-align: left; background: white; border: 2px solid lightblue;">Free Study Material</a>
				<a onclick="examQuiz()"  style="text-align: left; background: white; border: 2px solid lightblue;">Tests</a>
				<a onclick="examQuiz()"  style="text-align: left; background: white; border: 2px solid lightblue;">Quiz</a>
				<a onclick="examQuiz()"  style="text-align: left; background: white; border: 2px solid lightblue;">Live Mocks</a>
				<a onclick="examQuiz()"  style="text-align: left; background: white; border: 2px solid lightblue;">Saved Questions</a>
				<a onclick="examQuiz()"  style="text-align: left; background: white; border: 2px solid lightblue;">Order Details</a>
				<a onclick="examQuiz()"  style="text-align: left; background: white; border: 2px solid lightblue;">Settings</a>
				<a href="blog/.html"  id="popupLink" style="text-align: left; background: white; border: 2px solid lightblue;">Blog</a>
				

  
				<h3 style="text-align: right; background: lightblue;">Tools</h3>
						<button id="installButton">Install App</button>
						<button onclick="toggleDarkMode()" style="color: white; item-align: right; background: black; border: 2px solid white;">Dark Mode</button>
						
					


				<p style="height: 130px;"></p>
				
		</div>
    </div>
</div>



<main>

<div class="layer" id="layer1">


<div>
<div class="progress" style="height: 2px;">
  <div id="shuffleProgress" class="progress-bar" role="progressbar" style="width: 25%;" aria-valuenow="25" aria-valuemin="0" aria-valuemax="100"></div>
</div>

<div style="display: flex; justify-content: space-around; padding-bottom: 02px; font-weight: bold;">
			<h6> Hi!   <span id="userFirstName"></span> </h6>
			



<h6>Quant-Decimals</h6>

		

																													
																																
</div>

	<div style="display: flex; justify-content: space-between; padding-bottom: 02px;">
			
			<div>
			<input type="number" id="jumpToQuestion" min="1">
			<button onclick="jumpToQuestion()" style="border: 2px solid gray; font-size: 15px;">Jump</button></div>
			<button id="shuffleToggle" class="btn btn-warning" onclick="toggleShuffle()">Start</button>
			
			<div><input type="number" class="displayCount" id="completedCount"/><button onclick="saveCompletedWork()" style="border: 2px solid gray;">Complete</button></div>
	</div>



		<div class="takemargin" style="padding-bottom: 05px; color: white; font-size: 15px; font-weight: bold;">
		
		
				<button style=" font-size: 15px; font-weight: bold;">Q   <span id="totalQuestionCount" class="badge badge-light"></span> Save <span id="bookmarkedCount" class="badge badge-light"></span> Mark <span id="displayCount" class="badge badge-light"></span> </button><div id="toast" class="toast"></div>
				
		 
				<b class="btn-copy" style="cursor: pointer; font-size: 20px; ">üìã</b>
				
				
			
				<button class="btn btn-bookmark" onclick="toggleBookmark()">‚ú®</button>
		</div>

  <div class="question-container" id="question-container">
			<div id="question" class="h4" style="box-shadow: rgba(17, 17, 26, 0.05) 0px 4px 16px, rgba(17, 17, 26, 0.05) 0px 8px 32px; padding: 10px;"></div>
			<div id="options" style="box-shadow: rgba(9, 30, 66, 0.25) 0px 1px 1px, rgba(9, 30, 66, 0.13) 0px 0px 1px 1px; padding: 20px;"></div>
			<div class="explanation"></div>

	<div class="btn-container">
      <button class="btn btn-primary" onclick="showPreviousQuestion()" style="display: none;">Previous</button>
      <button class="btn btn-success" onclick="showAnswer()" style="display: none;">Open</button>
      <button class="btn btn-primary" onclick="showNextQuestion()" style="display: none;">Next</button>
    </div>
	
  </div>


</div>
   </main>
   
   <div class="navbot" id="navbot">
        <div>
		<a href="../../index.html" style="cursor: pointer; font-size: 15px; font-weight: bold; padding: 05px; border-radius: 04px; background: none; color: black; box-shadow: -03px 02px 01px 0px rgba(0, 0, 0, 0.3); filter: grayscale(50%);">üè†<span>Home</span>
        </a>
		<button onclick="hideBookmarkedQuestions()" style="font-size: 15px; font-weight: bold; padding: 00px; background: none; color: black; box-shadow: 00px 2px 00px rgba(0, 0, 0, 0.3); filter: grayscale(50%);">üìù<span>Quiz</span>
        </button>
       <button onclick="toggleDarkMode()" style="font-size: 15px; font-weight: bold; padding: 00px; background: none; color: black; box-shadow: 00px 02px 00px rgba(0, 0, 0, 0.3); filter: grayscale(100%);">üåì<span>Dark</span>
        </button>
		<button id="toggleBookmarkQuestions" onclick="togglePopulateBookmarkedQuestions()" style="font-size: 15px; font-weight: bold; padding: 00px; background: none; color: black; box-shadow: 00px 2px 00px rgba(0, 0, 0, 0.3); filter: grayscale(50%);">üîñ<span>Save</span>
        </button>
		<button onclick="showBookmarkedQuestions()" style="cursor: pointer; font-size: 15px; font-weight: bold; padding: 00px; background: none;  color: black; box-shadow: 03px 2px 00px rgba(0, 0, 0, 0.3); filter: grayscale(50%);">‚ú®<span>Booked</span>
        </button>

 </div>
    </div>

 

<!-- Layer 2 to display bookmarked questions -->
<div class="layer" id="layer2" style="display: none;">

<div class="exim">
<button onclick="exportBookmarksToFile()" style="background: indigo; color: white; font-size: 15px; padding: 02px;">Export ‚¨áÔ∏è</button>
<input type="file" id="importFileInput" style="display: none;" onchange="importBookmarksFromFile(event)">
<button onclick="document.getElementById('importFileInput').click()" style="background: indigo; color: white; font-size: 15px; padding: 02px;">Import ‚¨ÜÔ∏è</button>
  <h2>Bookmarked Questions</h2>
</div>

  <!-- Close button to hide layer 2 and show layer 1 -->
  <button class="btn btn-secondary" onclick="hideBookmarkedQuestions()" style="display: none;">Close</button>

  <div id="bookmarkedQuestions" style="overflow-y: scroll; position: fixed; top: 140px; max-height: 70%;"></div>
</div>




<script> 	
 const uniqueIdentifier = 'GangaTricks-ganga-x-0-Decimals';

let bookmarks = [];
let originalQuestionIndex; // Declare this variable at a higher scope
let currentQuestionIndex = 0;
const questionContainer = document.getElementById('question-container');
const questionElement = document.getElementById('question');
const optionsElement = document.getElementById('options');
let currentBookmarkIndex = 0; // Keep track of the current bookmarked question index
let populateBookmarkedQuestions = false;
let isShuffled = false;
let shuffledQuestions = [];
let shuffledBookmarkedIndices = [];
let totalBookmarkedQuestions = 0;
const shuffleToggle = document.getElementById('shuffleToggle');
const shuffleProgressBar = document.getElementById('shuffleProgress');


// Load the completed work count when the page loads
    window.onload = function() {
        displayCompletedWork();
        // Ensure input field reflects the saved count
        document.getElementById('completedCount').value = getCompletedWork();
    };

    function saveCompletedWork() {
        var completedCount = document.getElementById('completedCount').value;
        localStorage.setItem(`completedCount_${uniqueIdentifier}`, completedCount);
        displayCompletedWork(); // Update the displayed count immediately

        // Update input field value
        document.getElementById('completedCount').value = completedCount;
    }

    // Function to retrieve the completed work count from local storage
    function getCompletedWork() {
        return localStorage.getItem(`completedCount_${uniqueIdentifier}`) || '0';
    }

    // Function to display the completed work count from local storage
    function displayCompletedWork() {
        var completedCount = getCompletedWork();
        var displayCountElement = document.getElementById('displayCount');
        if (displayCountElement) {
            displayCountElement.textContent = completedCount; // Set count inside span
        }
        var completedCountDisplayElement = document.getElementById('completedCountDisplay');
        if (completedCountDisplayElement) {
            completedCountDisplayElement.textContent = `Mark: ${completedCount}üèÉ`; // Set count outside input field
        }
    }

    function getCurrentQuestion() {
        // Modify this function to return the current question based on the currentQuestionIndex
    }


// Function to shuffle an array using Fisher-Yates algorithm
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

		
		function getBookmarkedIndices() {
        const bookmarkedIndices = [];
        for (let i = 0; i < bookmarks.length; i++) {
            if (bookmarks[i]) {
                bookmarkedIndices.push(i);
            }
        }
        return bookmarkedIndices;
    }

  function togglePopulateBookmarkedQuestions() {
  resetQuestionContainer();
        populateBookmarkedQuestions = !populateBookmarkedQuestions;
        const toggleButton = document.getElementById('toggleBookmarkQuestions');
        toggleButton.textContent = populateBookmarkedQuestions ? '‚õîExit' : 'üîñSaved';
        showQuestion();
    }

function getBookmarkedIndices() {
    const bookmarkedIndices = [];
    
    if (Array.isArray(bookmarks)) {
        // Process as an array
        bookmarks.forEach((isBookmarked, index) => {
            if (isBookmarked) {
                bookmarkedIndices.push(index);
            }
        });
    } else if (typeof bookmarks === 'object' && bookmarks !== null) {
        // Process as an object
        for (let key in bookmarks) {
            if (bookmarks[key]) {
                const index = parseInt(key, 10);
                if (!isNaN(index)) {
                    bookmarkedIndices.push(index);
                }
            }
        }
    } else {
        console.warn('Bookmarks data is not in the expected format.');
    }

    return bookmarkedIndices;
}


function updateBookmarkedCount() {
    let bookmarkedCount = 0;

    // Check the type of bookmarks and process accordingly
    if (Array.isArray(bookmarks)) {
        // Process as an array
        bookmarkedCount = bookmarks.filter(Boolean).length;
    } else if (typeof bookmarks === 'object' && bookmarks !== null) {
        // Process as an object
        bookmarkedCount = Object.values(bookmarks).filter(Boolean).length;
    } else {
        console.warn('Bookmarks is neither an array nor an object. Count will be zero.');
    }

    // Update the UI with the count
    const bookmarkedCountElement = document.getElementById('bookmarkedCount');
    if (bookmarkedCountElement) {
        bookmarkedCountElement.textContent = `${bookmarkedCount}`;
    } else {
        console.error('Element with id "bookmarkedCount" not found');
    }
}

// toast message on bookmarking
function showToast(message) {
    var toast = document.getElementById("toast");
    toast.innerHTML = message;
    toast.className = "toast show";
    setTimeout(function () {
        toast.className = toast.className.replace("show", "");
    }, 3000); // The toast will disappear after 3 seconds
}
function toggleBookmark() {
    // Determine the original index based on currentQuestionIndex
    let originalQuestionIndex;

    // If in shuffle mode, find the original index from the shuffled questions
    if (isShuffled) {
        originalQuestionIndex = questions.indexOf(shuffledQuestions[currentQuestionIndex]);
    } else {
        // In normal mode, use the current question index directly
        originalQuestionIndex = currentQuestionIndex;
    }

    // Toggle the bookmarked state for the original question index
    bookmarks[originalQuestionIndex] = !bookmarks[originalQuestionIndex];

    // Save bookmarks to local storage
    saveBookmarksToLocalStorage();

    // Update the UI to reflect the new bookmarked state
    updateBookmarkButtonState(originalQuestionIndex);

    // Update the bookmark count
    updateBookmarkedCount();
	
	

    // Show a toast message indicating success or removal
    if (bookmarks[originalQuestionIndex]) {
        showToast("Question saved successfully!");
    } else {
        showToast("Question removed successfully!");
    }
}


function updateBookmarkButtonState(originalIndex) {
    const bookmarkButton = document.querySelector('.btn-bookmark');
    bookmarkButton.textContent = bookmarks[originalIndex] ? 'üîñ' : '‚ú®';
	
	
}



// Call the updateBookmarkedCount function when the window is fully loaded
window.addEventListener('load', function() {
  updateBookmarkedCount();
});


// Function to load the current question index from local storage
function loadCurrentQuestionIndex() {
  const storedIndex = localStorage.getItem(`${uniqueIdentifier}_currentQuestionIndex`); // Using unique identifier
  if (storedIndex !== null) {
    currentQuestionIndex = parseInt(storedIndex);
  }
}

// Call the function to load the current question index from local storage when the page loads
window.addEventListener('load', function() {
  loadCurrentQuestionIndex();
  showQuestion();
});

// Function to save the current question index to local storage
function saveCurrentQuestionIndex() {
  localStorage.setItem(`${uniqueIdentifier}_currentQuestionIndex`, currentQuestionIndex); // Using unique identifier
}

// Call the function to save the current question index to local storage when the user navigates to the next or previous question
window.addEventListener('beforeunload', function() {
  saveCurrentQuestionIndex();
});


        loadUserDataAndBookmarksFromLocalStorage(uniqueIdentifier);

        function saveUserDataAndBookmarksToLocalStorage(identifier) {
            localStorage.setItem(`userdata_bookmarks_${identifier}`, JSON.stringify(bookmarks));
        }

        function loadUserDataAndBookmarksFromLocalStorage(identifier) {
            const storedData = localStorage.getItem(`userdata_bookmarks_${identifier}`);
            if (storedData) {
                bookmarks = JSON.parse(storedData);
            }
        }

 function saveBookmarksToLocalStorage() {
            saveUserDataAndBookmarksToLocalStorage(uniqueIdentifier);
        }
	
		function exportBookmarksToFile() {
    const bookmarksData = JSON.stringify(bookmarks);
    const blob = new Blob([bookmarksData], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${document.title.replace(/[^a-zA-Z0-9]/g, '')}_bookmarks.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}


function importBookmarksFromFile(event) {
    const file = event.target.files[0];
    const reader = new FileReader();
    reader.onload = function (e) {
        const importedBookmarks = JSON.parse(e.target.result);
        if (importedBookmarks) {
            bookmarks = importedBookmarks;
            saveUserDataAndBookmarksToLocalStorage(uniqueIdentifier);
            showQuestion();
        }
    };
    reader.readAsText(file);
}
		
// Call the function to load bookmarks from local storage when the page loads
window.addEventListener('load', function() {
    loadUserDataAndBookmarksFromLocalStorage(uniqueIdentifier);
	
    showQuestion();
});

// Shuffle function to handle both normal and shuffled questions
function toggleShuffle() {
    isShuffled = !isShuffled;
    shuffleToggle.textContent = isShuffled ? 'Stop' : 'Start';

    if (isShuffled) {
        shuffledQuestions = shuffleArray([...questions]); // Shuffle questions
    } else {
        shuffledQuestions = [...questions]; // Reset to normal order
    }

    if (populateBookmarkedQuestions) {
        shuffledBookmarkedIndices = shuffleArray([...getBookmarkedIndices()]); // Shuffle bookmarked questions
    }

    currentQuestionIndex = 0; // Reset question index
    showQuestion(); // Show the first question
}

// Function to initialize and display bookmarked questions in normal order
function initializeBookmarkedQuestions() {
    const bookmarkedIndices = getBookmarkedIndices();
    if (bookmarkedIndices.length > 0) {
        shuffledBookmarkedIndices = [...bookmarkedIndices]; // Keep bookmarked questions in normal order initially
        totalBookmarkedQuestions = bookmarkedIndices.length;
        currentBookmarkIndex = 0;
    } else {
        totalBookmarkedQuestions = 0;
        shuffledBookmarkedIndices = [];
    }
}

// Show question function
function showQuestion() {
    let currentQuestion;

    // Initialize bookmarked questions if needed
    if (populateBookmarkedQuestions && shuffledBookmarkedIndices.length === 0) {
        initializeBookmarkedQuestions();
    }

    if (populateBookmarkedQuestions) {
        if (totalBookmarkedQuestions > 0) {
            currentQuestionIndex = shuffledBookmarkedIndices[currentBookmarkIndex];
            originalQuestionIndex = currentQuestionIndex; // Keep track of original index
            currentQuestion = questions[originalQuestionIndex]; // Get the original question
        } else {
            console.error('No bookmarked questions available.');
            return;
        }
    } else {
        if (isShuffled) {
            // Get the current question from the shuffled array
            currentQuestion = shuffledQuestions[currentQuestionIndex]; // Use the shuffled question
            originalQuestionIndex = questions.indexOf(currentQuestion); // Find original index
			
        } else {
            originalQuestionIndex = currentQuestionIndex; // In normal mode
            currentQuestion = questions[originalQuestionIndex]; // Use the normal question
        }
    }

    // Shuffle options and update UI
    const shuffledOptions = shuffleArray(currentQuestion.options);
	
    questionElement.innerHTML = `Q.${currentQuestionIndex + 1}/${originalQuestionIndex + 1}: ${currentQuestion.question}`;

    // Render options
    const optionsHTML = shuffledOptions.map((option, index) => `
        <div class="form-check">
            <input class="form-check-input" type="radio" name="option" value="${index}" id="option${index}">
            <label class="form-check-label" for="option${index}">
                <div class="option-border">${option}</div>
            </label>
        </div>
    `).join('');

    optionsElement.innerHTML = optionsHTML;
	
	 // Apply animations after rendering
    const optionContainers = document.querySelectorAll('.form-check');
    optionContainers.forEach((optionContainer, index) => {
        setTimeout(() => {
            optionContainer.style.opacity = '1';
            optionContainer.style.transform = 'translateY(0)';
        }, index * 100);
    });

    // Update bookmark button state based on the original index
    updateBookmarkButtonState(originalQuestionIndex);

    // Update progress bar
    updateProgressBar(populateBookmarkedQuestions ? totalBookmarkedQuestions : questions.length);
}





// Function to update progress bar
function updateProgressBar(totalQuestions) {
    const currentProgressIndex = populateBookmarkedQuestions ? currentBookmarkIndex + 1 : currentQuestionIndex + 1;
    const progress = (currentProgressIndex / totalQuestions) * 100;

    shuffleProgressBar.style.width = `${progress}%`;
    shuffleProgressBar.setAttribute('aria-valuenow', progress);
    shuffleProgressBar.textContent = ``; // write this code `${Math.round(progress)}%` into the blank field to shows percentage indication for question attempted so far
}

// Function to show the next question
function showNextQuestion() {
    resetQuestionContainer();

    if (populateBookmarkedQuestions) {
        if (totalBookmarkedQuestions > 0) {
            currentBookmarkIndex = (currentBookmarkIndex + 1) % totalBookmarkedQuestions;
            currentQuestionIndex = shuffledBookmarkedIndices[currentBookmarkIndex];
        } else {
            console.error('No bookmarked questions available.');
            return;
        }
    } else {
        currentQuestionIndex = (currentQuestionIndex + 1) % (isShuffled ? shuffledQuestions.length : questions.length);
    }

    showQuestion();
}

// Function to show the previous question
function showPreviousQuestion() {
    resetQuestionContainer();

    if (populateBookmarkedQuestions) {
        if (totalBookmarkedQuestions > 0) {
            currentBookmarkIndex = (currentBookmarkIndex - 1 + totalBookmarkedQuestions) % totalBookmarkedQuestions;
            currentQuestionIndex = shuffledBookmarkedIndices[currentBookmarkIndex];
        } else {
            console.error('No bookmarked questions available.');
            return;
        }
    } else {
        currentQuestionIndex = (currentQuestionIndex - 1 + (isShuffled ? shuffledQuestions.length : questions.length)) % (isShuffled ? shuffledQuestions.length : questions.length);
    }

    showQuestion();
}


function jumpToQuestion() {
    const jumpInput = document.getElementById('jumpToQuestion');
    const questionNumber = parseInt(jumpInput.value);
    
    if (!isNaN(questionNumber) && questionNumber >= 1 && questionNumber <= questions.length) {
        let targetIndex = questionNumber - 1;
        
        // Get the bookmarked indices
        const bookmarkedIndices = getBookmarkedIndices();
        
        // Check if the target index is bookmarked
        if (populateBookmarkedQuestions) {
            // If only bookmarked questions are being populated, then target index should be among bookmarked indices
            if (bookmarkedIndices.includes(targetIndex)) {
                // Set currentBookmarkIndex to the index of targetIndex in bookmarkedIndices
                currentBookmarkIndex = bookmarkedIndices.indexOf(targetIndex);
                currentQuestionIndex = targetIndex;
                showQuestion();
            } else {
                alert('Please enter a valid question number between 1 and ' + questions.length + ' that is bookmarked.');
            }
        } else {
            // If all questions are being populated, directly jump to the target index
            currentQuestionIndex = targetIndex;
            showQuestion();
        }
    } else {
        alert('Please enter a valid question number between 1 and ' + questions.length);
    }
}

function showAnswer() {
    const selectedOption = document.querySelector('input[name="option"]:checked');
    if (selectedOption) {
        // Check if we are in shuffle mode
        const currentQuestion = populateBookmarkedQuestions ? questions[shuffledBookmarkedIndices[currentBookmarkIndex]] : (isShuffled ? shuffledQuestions[currentQuestionIndex] : questions[currentQuestionIndex]);
        const selectedValue = parseInt(selectedOption.value);
        const isCorrect = currentQuestion.correctOption === currentQuestion.options[selectedValue];

        // Display selected option feedback
        const selectedLabel = selectedOption.parentElement.querySelector('.form-check-label');
        selectedLabel.innerHTML += isCorrect ? ' <i class="fas fa-check text-success"></i>' : ' <i class="fas fa-times text-danger"></i>';
        selectedLabel.classList.add(isCorrect ? 'text-success' : 'text-danger');

        // Display correct option feedback
        const correctOptionIndex = currentQuestion.options.findIndex(option => option === currentQuestion.correctOption);
        const correctOptionBorder = document.querySelector(`#option${correctOptionIndex} + .form-check-label .option-border`);

        if (correctOptionBorder) {
            correctOptionBorder.innerHTML += ' <span class="text-success-transparent">‚òëCorrect</span>';
            correctOptionBorder.classList.add('text-success-transparent');
            correctOptionBorder.classList.add('shake'); // Apply shake class
        }

        // Display explanation
        const explanation = document.createElement('p');
        explanation.innerHTML = `<button class="cool">${currentQuestion.correctOption || ''}</button><br><h6 class="explanation-text">${currentQuestion.explanation || ''}</h6>`.replace(/\n/g, '<br>');
        optionsElement.appendChild(explanation);
    }
}


document.addEventListener('change', function(event) {
  if (event.target.tagName.toLowerCase() === 'input' && event.target.type === 'radio' && event.target.name === 'option') {
    showAnswer();
  }
});

function resetQuestionContainer() {
    questionContainer.classList.remove('current-question');
    setTimeout(() => {
      questionContainer.classList.add('current-question');
    }, 10); // Small delay to ensure smooth transition
  }
  
function showBookmarkedQuestions() {
  // Hide layer 1
  const layer1 = document.getElementById('layer1');
  layer1.style.display = 'none';

  // Get the container for bookmarked questions
  const bookmarkedQuestionsContainer = document.getElementById('bookmarkedQuestions');
  bookmarkedQuestionsContainer.innerHTML = ''; // Clear previous content

  // Initialize count for bookmarked questions
  let bookmarkedCount = 0;

  // Iterate through all questions to collect bookmarked ones
  for (let i = 0; i < questions.length; i++) {
    if (bookmarks[i]) {
      bookmarkedCount++; // Increment bookmarked count

      // Create a div for each bookmarked question
      const questionDiv = document.createElement('div');
      questionDiv.classList.add('bookmarked-question');

      // Display the question
      const questionText = document.createElement('p');
      questionText.textContent = `Question ${i + 1}: ${questions[i].question}`;
	  questionText.style.fontSize = '18px'; // Change the font size as needed
      questionDiv.appendChild(questionText);

      // Display the options as radio buttons
      const optionsList = document.createElement('ul');
      optionsList.style.listStyleType = 'none';
      for (let j = 0; j < questions[i].options.length; j++) {
        const optionItem = document.createElement('li');
        const optionLabel = document.createElement('label');
        const optionInput = document.createElement('input');
        optionInput.type = 'radio';
        optionInput.name = `question${i}`;
        optionInput.value = j;
        optionInput.addEventListener('change', function() {
          // Highlight the correct option when any option is selected
          const correctOptionIndex = questions[i].options.indexOf(questions[i].correctOption);
          const correctOptionLabel = optionsList.querySelectorAll('label')[correctOptionIndex];
          correctOptionLabel.style.backgroundColor = 'lightgreen';
        });
        optionLabel.textContent = questions[i].options[j];
        optionLabel.prepend(optionInput);
        optionItem.appendChild(optionLabel);
        optionsList.appendChild(optionItem);
      }
      questionDiv.appendChild(optionsList);

      // Add a button to check the correct answer
      const checkAnswerButton = document.createElement('button');
      checkAnswerButton.textContent = 'Check Answer';
      checkAnswerButton.onclick = function() {
        // Get the selected option
        const selectedOption = optionsList.querySelector('input:checked');
        if (selectedOption) {
          const selectedIndex = parseInt(selectedOption.value);
          if (questions[i].options[selectedIndex] === questions[i].correctOption) {
            // Highlight the correct option
            const correctOptionIndex = questions[i].options.indexOf(questions[i].correctOption);
            const correctOptionLabel = optionsList.querySelectorAll('label')[correctOptionIndex];
            correctOptionLabel.style.backgroundColor = 'gray';
          }
        } else {
          // No option selected
          alert('Please select an option.');
        }
      };
      questionDiv.appendChild(checkAnswerButton);

      // Add a button to remove the bookmark
      const removeBookmarkButton = document.createElement('button');
      removeBookmarkButton.textContent = 'Remove Bookmark';
      removeBookmarkButton.onclick = function() {
        // Remove the bookmark for this question
        bookmarks[i] = false;
        // Update the UI to reflect the change
        showBookmarkedQuestions(); // Update the bookmarked questions list
      };
      questionDiv.appendChild(removeBookmarkButton);

      // Add the bookmarked question to the container
      bookmarkedQuestionsContainer.appendChild(questionDiv);
    }
  }
// Display total bookmarked questions count
const bookmarkedCountElement = document.createElement('p');
bookmarkedCountElement.textContent = `Total Bookmarked Questions: ${bookmarkedCount}`;
bookmarkedCountElement.style.color = 'black'; // Set text color to blue
bookmarkedCountElement.style.fontWeight = 'bold'; // Make text bold
bookmarkedCountElement.style.fontSize = '14px'; // Set font size
bookmarkedCountElement.style.backgroundColor = 'gold'; // Add background color
bookmarkedCountElement.style.padding = '8px'; // Add padding for better appearance
bookmarkedCountElement.style.marginBottom = '10px'; // Add some margin bottom for spacing
bookmarkedQuestionsContainer.prepend(bookmarkedCountElement);

  // Show layer 2
  const layer2 = document.getElementById('layer2');
  layer2.style.display = 'block';
}


function hideBookmarkedQuestions() {
  // Hide layer 2
  const layer2 = document.getElementById('layer2');
  layer2.style.display = 'none';

  // Show layer 1
  const layer1 = document.getElementById('layer1');
  layer1.style.display = 'block';
}

// Unlimited Scrolling codes start from here

    var bookmarkedQuestions = document.getElementById('bookmarkedQuestions');
    var lastScrollTop = 0;

    // Function to load more content when the user scrolls to the bottom
    function loadMoreContent() {
      var scrollTop = bookmarkedQuestions.scrollTop;
      var scrollHeight = bookmarkedQuestions.scrollHeight;
      var clientHeight = bookmarkedQuestions.clientHeight;

      if (scrollTop > lastScrollTop) {
        if (scrollTop + clientHeight >= scrollHeight) {
          // Load more content here
          // Example: fetch more bookmarked questions from the server and append them to the #bookmarkedQuestions element

          // For example:
          // fetch('/load-more-bookmarked-questions')
          //   .then(response => response.json())
          //   .then(data => {
          //     // Append the new questions to the #bookmarkedQuestions element
          //     // Example: data.forEach(question => { /* Append question to #bookmarkedQuestions */ });
          //   });
        }
      }

      lastScrollTop = scrollTop <= 0 ? 0 : scrollTop; // For Mobile or negative scrolling
    }

    // Add event listener for scroll events
    bookmarkedQuestions.addEventListener('scroll', loadMoreContent);

// Unlimited Scrolling codes end here

document.addEventListener('keydown', function(event) {
  switch (event.key) {
    case 'ArrowLeft':
      showPreviousQuestion();
      break;
    case 'ArrowRight':
      showNextQuestion();
      break;
    case 'ArrowUp':
      showAnswer();
      break;
    case '1':
    case '2':
    case '3':
    case '4':
	case '5':
      // Convert the key to an index (0-based)
      const index = parseInt(event.key) - 1;
      const radios = document.getElementsByName('option');
      if (index >= 0 && index < radios.length) {
        radios[index].checked = true;
      }
      break;
    default:
      break;
  }
});

let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;
let isSwipe = false;


document.addEventListener('touchstart', function(event) {
  touchStartX = event.touches[0].clientX;
  touchStartY = event.touches[0].clientY;
  isSwipe = false; // Reset the flag for each touchstart
});

document.addEventListener('touchmove', function(event) {
  touchEndX = event.touches[0].clientX;
  touchEndY = event.touches[0].clientY;

  // Calculate the distance moved in the X and Y directions
  const deltaX = touchEndX - touchStartX;
  const deltaY = touchEndY - touchStartY;

  // If the distance moved in the X direction is greater than the threshold, consider it a swipe
  if (Math.abs(deltaX) > 10) {
    isSwipe = true;
  }
});

document.addEventListener('touchend', function(event) {
  if (isSwipe) {
    const deltaX = touchEndX - touchStartX;
    const deltaY = touchEndY - touchStartY;

    const touchSensitivity = 50; // Adjust as needed

    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > touchSensitivity) {
      if (deltaX > 0) {
        // Swipe right (previous question)
        showPreviousQuestion();
      } else {
        // Swipe left (next question)
        showNextQuestion();
      }
    } else if (Math.abs(deltaY) > touchSensitivity) {
      if (deltaY < 0) {
        // Swipe up (open answer)
        ; 				// write showAnswer(); to enable it in this very line 
      }
    }
  }
});




 function goToHub() {
        // Change 'https://example.com' to the actual URL you want to redirect to
        window.location.href = '../../awareness/awareness1.html';
    }

  function goToWebsite() {
        // Change 'https://example.com' to the actual URL you want to redirect to
        window.location.href = '../../index.html';
    }
 function examQuiz() {
        // Change 'https://example.com' to the actual URL you want to redirect to
        window.location.href = '../../examquiz/examquiz.html';
    }

 function goToEnglish() {
        // Change 'https://example.com' to the actual URL you want to redirect to
        window.location.href = '../../english/english1.html';
    }


  

	// Function to toggle dark mode
function toggleDarkMode() {
    const body = document.body;
    const isDarkMode = body.classList.contains('dark-mode');
    
    // Toggle the class and set the cookie
    if (isDarkMode) {
        body.classList.remove('dark-mode');
        setDarkModeCookie(false); // Set cookie to false (light mode)
    } else {
        body.classList.add('dark-mode');
        setDarkModeCookie(true); // Set cookie to true (dark mode)
    }
}

// Function to set the dark mode cookie
function setDarkModeCookie(isDarkMode) {
    document.cookie = `darkMode=${isDarkMode}; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/`;
}

// Function to check if dark mode preference is stored in the cookie and apply it
function applyDarkModeFromCookie() {
    const cookies = document.cookie.split(';');
    for (let cookie of cookies) {
        const [name, value] = cookie.trim().split('=');
        if (name === 'darkMode' && value === 'true') {
            document.body.classList.add('dark-mode');
            return;
        }
    }
}

// Apply dark mode preference from the cookie on page load
applyDarkModeFromCookie();

function toggleSidebar() {
  var sidebar = document.getElementById("sidebar");
  if (sidebar.style.left === "-250px") {
    sidebar.style.left = "0";
  } else {
    sidebar.style.left = "-250px";
  }
}

   function goBack() {
            window.history.back();
        }
	
        var prevScrollpos = window.pageYOffset;

        window.onscroll = function() {
            var currentScrollPos = window.pageYOffset;
            var navbar = document.getElementById('navbot');

            if (prevScrollpos > currentScrollPos) {
                navbar.classList.remove('hidden');
            } else {
                navbar.classList.add('hidden');
            }

            prevScrollpos = currentScrollPos;
        };
	

const copyButton = document.querySelector('.btn-copy');

        // Add a click event listener to the "Copy to Clipboard" button
        copyButton.addEventListener('click', () => {
            const questionText = document.querySelector('#question').textContent;
            const optionElements = document.querySelectorAll('.form-check-label');
            
            let optionsText = '';
            let correctOption = null;

            optionElements.forEach((optionElement, index) => {
                const optionText = optionElement.textContent.trim();
                const isCorrect = optionElement.querySelector('.text-info'); // Check for correct answer indication
                optionsText += `Option ${index + 1}: ${optionText}${isCorrect ? '' : ''}\n`;

                if (isCorrect) {
                    correctOption = `correctOption is Option ${index + 1}: ${optionText}`;
                }
            });

            const textToCopy = `${questionText}\n\n${optionsText}\n${correctOption ? correctOption : ''}`;

            const textarea = document.createElement('textarea');
            textarea.value = textToCopy;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);

            // Toggle button text
            copyButton.textContent = '‚úÖ';
            setTimeout(() => {
                copyButton.textContent = 'üìã';
            }, 2000); // Reset text after 2 seconds
        });
		
	


</script>

		
       
<script>
const questions = [


	];

showQuestion(); // Initial display of the first question
 function updateTotalQuestionCount() {
      const totalQuestionCount = questions.length;
      document.getElementById('totalQuestionCount').textContent = totalQuestionCount;
    }

    // Call the function to update total question count initially
    updateTotalQuestionCount();
</script>
</body>
</html>
